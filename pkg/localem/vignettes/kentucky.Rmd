<!--
%\VignetteEngine{knitr::docco_linear}
%\VignetteIndexEntry{Local-EM Example with Cancer Cases in Kentucky}
-->
	
# Local-EM Example with Cancer Cases in Kentucky
	
## Introduction 

The `localEM` package contains functions to implement the kernel smoothing local-EM algorithm$^1$ of disease data aggregated to geographical regions. This algorithm provides an nonparametric alternative to the standard geospatial models, such as the Besag-York-Mollie (BYM) model$^2$, for estimating spatial risk of areal disease data. With disease cases typically aggregated to highly coarse geographical regions (e.g., census counties, or census subdivisions), the local-EM method creates a tessellation of distinct regions by overlaying the map of these coarse regions with another map containing fine geographical regions (e.g., census tracts, census blocks, or census dissemination areas) of population data. This allows for the spatial risk to be estimated at a better resolution with the fine regions. 

The methodology of this package is demonstrated on simulated lung cancer cases for the state of Kentucky, USA. The spatial polygons for the census counties and tracts of Kentucky are included with this package. 

```{r setup, message = FALSE}

library('mapmisc')

data('kentuckyCounty', package='localEM') 
data('kentuckyTract', package='localEM')
data('kMap', package='localEM')

# specify number of grid cells and
# number of cores for computations in parallel 
# (only applicable to UNIX operating systems)
if(Sys.info()['user'] == 'patrick' & interactive()) {
	# this uses about 20GB of memory
	cellsFine = 200
	ncores = 8
	cellsCoarse=30
} else {
	ncores = ifelse(.Platform$OS.type == 'unix', 2, 1)
	cellsFine = 60
	cellsCoarse=15
}

```



## Simulate Cases

Using the `simLgcp()` function from the `geostatsp` package, case locations are
simulated with the log Gaussian Cox process and  following parameters: 

* mean: 0
* variance: 0.16
* shape: 2
* range: 120 km
* offsets: log of expected cases/m$^2$ of the census tracts

The simulated cases are then aggregated to the appropriate counties. 

```{r simcases, message = FALSE}

kentuckyOffset = geostatsp::spdfToBrick(
  kentuckyTract,
  geostatsp::squareRaster(kentuckyTract, 400),
  pattern = '^expected$',
  logSumExpected=TRUE
  )


set.seed(0)
kCases = geostatsp::simLgcp(
  param = c(mean = 0, variance = 0.4^2, 
    range = 120 * 1000, shape = 2),
   covariates = list(logExpected = kentuckyOffset), 
  offset = 'logExpected')
#'
```

Aggregate events to counties

```{r aggSim}

kCases$events = SpatialPointsDataFrame(
  kCases$events,
  data=over(kCases$events, kentuckyCounty)[,'id',drop=FALSE]
)
countyCounts = table(kCases$events$id,exclude=NULL)
kentuckyCounty$count = as.vector(countyCounts[kentuckyCounty$id])
```


Remove events simulated outside a county.  

```{r totalEvents}
sum(kentuckyCounty$count)
length(kCases$events)
sum(is.na(kCases$events$id))
kCases$events = kCases$events[!is.na(kCases$events$id), ]
length(kCases$events)
```

```{r plotOffset, echo = FALSE, fig.cap='simulated events', fig.subcap = c('offset','relative intensity', 'events', 'counts')}

# offset map
oCol = colourScale(
  c(0, exp(maxValue(kentuckyOffset))), 
  breaks = 10, 
  style = 'equal', dec = 7, 
  transform = 'sqrt')

map.new(kentuckyTract)
plot(kentuckyOffset, 
  col = oCol$col, 
  breaks = pmax(-100,log(oCol$breaks)), 
  legend = FALSE, 
  add = TRUE)
plot(kMap, add = TRUE)

legendBreaks('topleft', 
  breaks = oCol$breaks * 10^6, col = oCol$col, 
  title = expression(plain('cases/km')^2), 
  bg = 'white')


  
# simulated risk map
  iCol = colourScale(
    kCases$raster$relativeIntensity, 
  breaks = 8, style = 'equal', dec = -log10(0.5))
  
  map.new(kentuckyTract)
  
  plot(kCases$raster$relativeIntensity, 
  col = iCol$col, breaks = iCol$breaks, 
  legend = FALSE, 
  add = TRUE)
  plot(kMap, add = TRUE)
  
  legendBreaks('topleft', 
  col = iCol$col, breaks = iCol$breaks, 
  title = 'relative risk', 
  bg = 'white')

  
# simulated events map
  map.new(kentuckyTract)
  plot(kMap, add = TRUE)
  
  points(kCases$events, col = '#FF000030', pch = 20, cex=0.5)
  
  scaleBar(kentuckyCounty, 
  pos = 'topleft',   bg = 'white')
  
# simulated counts
cCol = colourScale(
  kentuckyCounty$count, 
  breaks = 10, 
  style = 'quantile', dec = -1)

map.new(kentuckyTract)
plot(kentuckyCounty, col=cCol$plot, add=TRUE)
plot(kMap, add = TRUE)
legendBreaks("topleft", cCol)


scaleBar(kentuckyCounty, 
  pos = 'topleft',   bg = 'white')
```



## Cross-validation

```{r cvNew}
xvKentucky = localEM::lemXv(
  polyCoarse = kentuckyCounty,   
  polyFine = kentuckyTract,   
  cellsCoarse = cellsCoarse,   
  cellsFine = cellsFine,   
  bw = seq(20, 200, by=20) * 1000,
  xv = 4, 
  ncores = ncores,
  path = tempdir(),
  verbose = TRUE)
if(Sys.info()['user'] == 'patrick' & interactive()) {
	save(xvKentucky, file='xvKentucky.RData')
}  
```

```{r cvPlotNew, fig.cap='cross validation scores', fig.height=4, fig.width=6}
plot(xvKentucky$xv[,1]/1000, xvKentucky$xv[,2], 
	xlab='km', ylab='-log p', 
    type='o', ylim=quantile(xvKentucky$xv[,2], c(0,0.5)))
```

## Rasters

The case data are observed at the county level (coarse polygon regions) while the population data are measured at the census tract level (fine polygon regions). The expected counts are computed with the age-sex population of the census tracts and rates from http://www.cancer-rates.info/, and then, scaled appropriately for this example. 

The tessellation of distinct regions, also known as partitions, is generated with the `lemRaster()` function. The census counties and tracts are first rasterized with different resolutions, and then, these coarse and fine rasters are overlayed to create the partitions of interest. This function also generates the focal weight matrix of the Gaussian smoothing kernel for specified bandwidths to be used for the smoothing matrix computations. 


Afterwards, the likelihood cross-validation (CV) approach is implemented with the `lemXv()` function to select the optimal bandwidth (i.e., the one that yields the smallest CV score) from the set of specified bandwidths. CV scores are computed with k-fold sampling without replacement of the case data. 

```{r cv}
bestBw = xvKentucky$xv[which.min(lemXvKentucky$xv[,2]),1]
```


# Risk Estimation

The local-EM risk estimation is done with the `riskEst()` function for the optimal bandwidth found in the CV analysis. The risk is estimated with the same resolution as the fine raster. 

```{r riskEst}

lemRisk = riskEst(
  x = kentuckyCounty, 
  lemObjects = lemSmoothMat,
  bw = bestBw, 
  ncores = ncores)

```

```{r plotRisk, echo = FALSE}

rCol = colourScale(lemRisk, 
  breaks = 10, style = 'equal', dec = 1)

map.new(kentuckyTract, 
  mar = c(0, 0, 1, 0), 
  main = 'Risk Estimation')
plot(lemRisk, 
  col = rCol$col, breaks = rCol$breaks, 
  legend = FALSE, 
  add = TRUE)
plot(kMap, add = TRUE)

legendBreaks('topleft', 
  col = rCol$col, breaks = rCol$breaks, 
  title = 'relative risk', 
  bg = 'white')

scaleBar(kentuckyCounty, 
  pos = 'topleft', 
  inset = c(0.3, 0.1), 
  bg = 'white')

```


## Exceedance Probabilities

Exceedance probabilities are computed with the `excProb()` function to measure the uncertainty of the local-EM risk estimation. Bootstrapping is used to obtain these exceedance probabilities for the local-EM algorithm. 

Specifically, under the assumption that disease events are a realisation from the background population and constant risk threshold, cases are bootstrapped and randomly aggregated to the counties. Using the same bandwidth as the observed data, the local-EM risk is then estimated for each of the bootstrapped data. Afterwards, exceedance probabilities are computed as the proportion of the observed risk estimate at least as large as the ones of the bootstrap data. Large exceedance probabilities are consistent with the risk being greater than the specified threshold. 

```{r excProb}

lemExcProb = excProb(
  lemEst = lemRisk, 
  lemObjects = lemSmoothMat, 
  threshold = c(1, 1.25, 1.5, 2), 
  Nboot = 200, 
  ncores = ncores)

```

```{r plotExcProb, echo = FALSE}

#exceedance probability maps
pCol = colourScale(lemExcProb, 
  breaks = c(0, 0.2, 0.8, 0.95, 1), style = 'fixed', 
  col = c('green', 'yellow', 'orange', 'red')
)								

for(Dthreshold in names(lemExcProb)) {
  
  threshold = gsub('threshold\\.', '', Dthreshold)
  map.new(kentuckyTract, 
    mar = c(0, 0, 1, 0), 
    main = paste('Exceedance Probabilities, t = ', threshold, sep = ''))
  plot(lemExcProb[[Dthreshold]], 
    col = pCol$col, breaks = pCol$breaks, 
    legend = FALSE, 
    add = TRUE)
  plot(kMap, add = TRUE)
  
  legendBreaks('topleft', 
    col = pCol$col, breaks = pCol$breaks, 
    title = 'prob', 
    bg = 'white')
  
  scaleBar(kentuckyCounty, 
    pos = 'topleft', 
    inset = c(0.3, 0.1), 
    bg = 'white')
}

```

## References

1. Nguyen P, Brown PE, Stafford J. Mapping cancer risk in southwestern Ontario with changing census boundaries. Biometrics. 2012; 68(4): 1229-37. 

2. Besag J, York J, Mollie A. Bayesian image restoration, with two applications in spatial statistics. Ann Inst Statist Math. 1991; 43(1): 1-59. 
